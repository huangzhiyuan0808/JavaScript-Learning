<script>
  /*
var obj1 = {a:1, b:2};
var obj2 = {a:1, b:2};
console.log(obj1 == obj2);
console.log(obj1 = obj2);
console.log(obj1 === obj2);


console.log('-------------')


var a = 1
var b = 2
var c = { name: '饥人谷', age: 2 }
var d = [a, b, c]

var aa = a
var bb = b
var cc = c
var dd = d

a = 11
b = 22
c.name = 'hello'
d[2]['age'] = 3

console.log(aa) 
console.log(bb) 
console.log(cc)
console.log(dd)




console.log('-------------')



*/


  var a = 1
  var c = { name: 'jirengu', age: 2 }

  function f1(n) {
    ++n
  }
  function f2(obj) {
    ++obj.age
  }

  f1(a) //a是非引用类型，按值传递，传入f1后，相当于在 f1 的作用域内 有 var n = a，此时 n 开辟了新的内存用来存放 1，不影响a
  f2(c) //c是引用类型，按引用传递，传入f2后，相当于 var obj = c，这里obj虽然也开辟了新的内存，但仅仅是用来存放和c同样的内存地址，存的是一个地址坐标，obj 和 c 共同指向相同的堆内存，操作的时候是操作的堆内存，所以改变了 c.age
  f1(c.age) //c.age 作为参数传入 f1 的时候，实质就已经是 number 了，n 开辟了新的内存
  console.log(a) //所以输出 1
  console.log(c) //所以输出 { name: 'jirengu', age: 3 }






  // var a
  // var c 

  // function f1(n){
  //   ++n
  // }
  // function f2(obj){
  //   ++obj.age
  // }

  // a = 1
  // c = { name: 'jirengu', age: 2 }



  // f1(a) //a = 2 
  // f2(c) //c.age = 3
  // f1(c.age) //c.age = 4
  // console.log(a) //2
  // console.log(c) //4



  // 过滤如下数组，只保留正数，直接在原数组上操作

  var arr = [3, 1, 0, -1, -3, 2, -5]
  function filter(arr) {
    for (var i = 0; i < arr.length; i++) {
      if (arr[i] <= 0) {
        arr.splice(i, 1)
        filter(arr)
      }
    }
  }
  filter(arr)
  console.log(arr) // [3,1,2]




// 过滤如下数组，只保留正数，原数组不变，生成新数组

var arr = [3, 1, 0, -1, -3, 2, -5];
var arr2 = [];
function filter(arr) {
  for (var i = 0; i < arr.length; i++) {
    if (arr[i] > 0) {
      arr2.push(arr[i]); // push方法，可以向 arr2 数组的末尾添加一个或多个元素，并返回新的长度
    }
  }
}
filter(arr);
console.log(arr2) // [3,1,2]
console.log(arr)  // [3,1,0,-1,-2,2,-5]










</script>